#include <Arduino.h>
#include <MPU6050.h>

// Logging mode
#define  NOLOG
//#define  LOGSERIAL
//#define LOGSDCARD  // log to SD Card
//#define LOGTRACE   // Enable trace
#include <log.h>
//File logFile; 

MPU6050Class::MPU6050Class(void)
{
    _temperature = 0;
}


uint8_t MPU6050Class::MPU6050_checkDeviceID()
{
    uint8_t deviceID = MPU6050_readReg(WHO_AM_I);
    if (_last_status > 0) return _last_status;
    
    if (deviceID == MPU6050_ID) return 0;
    else return deviceID;
}

uint8_t MPU6050Class::MPU6050_init()
{
    PRINTs(">>>Start  MPU_init") 
    
    // Setup I2C
    _address =ADDRESS_DEFAULT;  
    PRINTx("_address: ",_address)

    
    // Reset
    MPU6050_writeReg(PWR_MGMT_1, B10000000); //PWR_MGMT_1    -- DEVICE_RESET
    if (_last_status > 0) return _last_status;
    delay(50); // small delay of ~50ms may be desirable after triggering a reset
   
    /*old
    // Wake up device and select GyroZ clock (better performance)
    MPU6050_writeReg(PWR_MGMT_1, B00000011); //PWR_MGMT_1    -- SLEEP 0; CYCLE 0; TEMP_DIS 0; CLKSEL 011 (clock source is set to PLL with Z Gyro reference)
    if (_last_status > 0) return _last_status;
    old*/    
    // Wake up device and select Internal 8MHZ oscillator (p 220)
    MPU6050_writeReg(PWR_MGMT_1, B00000000); //PWR_MGMT_1    -- SLEEP 0; CYCLE 0; TEMP_DIS 0; CLKSEL 000 (clock source is set to Internal 8MHZ oscillator)
    if (_last_status > 0) return _last_status;
        
     //old
     /** Set the The DLPF_CFG parameter = the digital low pass filter configuration.    
     * It also determines the internal sampling rate used by the device as shown in
     * the table below.
     *          |   ACCELEROMETER    |           GYROSCOPE
     * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
     * ---------+-----------+--------+-----------+--------+-------------
     * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
     * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
     * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
     * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
     * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
     * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
     * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
     * => Choose DLPF_CFG = 4 => ACC bandwidth = 21Hz  GYRO bandwidth = 20Hz: compromise between filtering noise and delay
     */
     /*old
    MPU6050_writeReg(CONFIG, B00000100); //CONFIG        -- EXT_SYNC_SET 000 (disable input pin for data sync) ; DLPF_CFG = 4 (100) => ACC bandwidth = 21Hz  GYRO bandwidth = 20Hz
    if (_last_status > 0) return _last_status;
    old*/
    /** Set the The DLPF_CFG parameter = the digital low pass filter configuration.    
     * It also determines the internal sampling rate used by the device as shown in
     * the table below.
     *          |   ACCELEROMETER    |           GYROSCOPE
     * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
     * ---------+-----------+--------+-----------+--------+-------------
     * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
     * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
     * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
     * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
     * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
     * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
     * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
     * => Choose DLPF_CFG = 3 => ACC bandwidth = 44Hz  GYRO bandwidth = 42Hz: compromise between filtering noise and delay
     */
    MPU6050_writeReg(CONFIG, B00000011); //CONFIG        -- EXT_SYNC_SET 000 (disable input pin for data sync) ; DLPF_CFG = 3 (011) => ACC bandwidth = 44Hz  GYRO bandwidth = 42Hz p226
    if (_last_status > 0) return _last_status;
   
    /** The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
     *
     * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     *
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
     * 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a Sample
     * Rate greater than 1kHz, the same accelerometer sample may be output to the
     * FIFO, DMP, and sensor registers more than 
     * => Choose Divider = 4 => Sample rate = 1Khz/(4+1) = 200Hz ie 5ms
     */ 
    /*old       
    MPU6050_writeReg(SMPRT_DIV, 4); //SMPRT_DIV        -- Divider = 4
    if (_last_status > 0) return _last_status;
    old*/
    /** The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
     *
     * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     *
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
     * 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a Sample
     * Rate greater than 1kHz, the same accelerometer sample may be output to the
     * FIFO, DMP, and sensor registers more than 
     * => Choose Divider = 0 => Sample rate = 1Khz/(0+1) = 1Khz ie 1ms
     */        
    MPU6050_writeReg(SMPRT_DIV, 0); //SMPRT_DIV        -- Divider = 0
    if (_last_status > 0) return _last_status;
                
    /*old    
    MPU6050_writeReg(GYRO_CONFIG, B00000000); //GYRO_CONFIG   -- no Self test -- FS_SEL = 000: (Full Scale Range set to +/- 250 deg/sec)
    if (_last_status > 0) return _last_status;
    old*/
    MPU6050_writeReg(GYRO_CONFIG, B00001000); //GYRO_CONFIG   -- no Self test -- FS_SEL = 001: (Full Scale Range set to +/- 500 deg/sec i.e. 1.4 tr/sec) p222
    if (_last_status > 0) return _last_status;
    
    /*old     
    MPU6050_writeReg(ACCEL_CONFIG, B00000000);  //ACCEL_CONFIG  -- no Self test -- AFS_SEL = 00 (Full Scale Range set to +/-2g) 
    if (_last_status > 0) return _last_status;
    old*/
    MPU6050_writeReg(ACCEL_CONFIG, B00010000);  //ACCEL_CONFIG  -- no Self test -- AFS_SEL = 10 (Full Scale Range set to +/-8g) p224
    if (_last_status > 0) return _last_status;
          
    _previousTime = 0;
  
    PRINTs("<<<End OK MPU_init")

    return 0;
}

// Write an 8-bit register
void MPU6050Class::MPU6050_writeReg(uint8_t reg, uint8_t value)
{
  Wire.beginTransmission(_address);
  Wire.write(reg);
  Wire.write(value);
  _last_status = Wire.endTransmission();
}

// Read an 8-bit register
uint8_t MPU6050Class::MPU6050_readReg(uint8_t reg)
{
  uint8_t value=0;

  Wire.beginTransmission(_address);
  Wire.write(reg);
  _last_status = Wire.endTransmission();
  if (_last_status > 0) return _last_status;

  _last_nb_receive = Wire.requestFrom(_address, (uint8_t)1);
  if (_last_nb_receive != 1) {_last_status=WIRE_REQUEST_ERROR; return _last_status;}  
  
  value = Wire.read();

  return value;
}

// Read a 16-bit register high byte first and then low byte
int16_t MPU6050Class::MPU6050_readReg16BitHL(uint8_t reg)
{
  int16_t value;

  Wire.beginTransmission(_address);
  Wire.write(reg);
  _last_status = Wire.endTransmission();
  if (_last_status > 0) return _last_status;
  
  _last_nb_receive = Wire.requestFrom(_address, (uint8_t)2);
  if (_last_nb_receive != 7) {_last_status=WIRE_REQUEST_ERROR; return _last_status;} 
  
  uint8_t msb = Wire.read(); // value high byte
  uint8_t lsb = Wire.read(); // value low byte
  
  value  = (((int16_t)msb) << 8) | lsb;

  return value;
}


double MPU6050Class::MPU6050_getAccel_x()
{
  int16_t accel_x = MPU6050_readReg16BitHL(ACCEL_XOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_x / 16384.0) - _accel_zero_x);  // Full Scale Range ?2g => 16384 LSB/g
}
double MPU6050Class::MPU6050_getAccel_y()
{
  int16_t accel_y = MPU6050_readReg16BitHL(ACCEL_YOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_y / 16384.0) - _accel_zero_y); // Full Scale Range ?2g => 16384 LSB/g
}
double MPU6050Class::MPU6050_getAccel_z()
{
  int16_t accel_z = MPU6050_readReg16BitHL(ACCEL_ZOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_z / 16384.0) - _accel_zero_z); // Full Scale Range ?2g => 16384 LSB/g
}

double MPU6050Class::MPU6050_getGyro_x()//roll
{
  int16_t gyro_x = MPU6050_readReg16BitHL(GYRO_XOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_x / 131.0) - _gyro_zero_roll);  // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}
double MPU6050Class::MPU6050_getGyro_y()//pitch
{
  int16_t gyro_y = MPU6050_readReg16BitHL(GYRO_YOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_y / 131.0) - _gyro_zero_pitch); // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}
double MPU6050Class::MPU6050_getGyro_z() //yaw
{
  int16_t gyro_z = MPU6050_readReg16BitHL(GYRO_ZOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_z / 131.0) - _gyro_zero_yaw); // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}

uint8_t MPU6050Class::MPU6050_calibrate()
{
  int nb_mesures = 2000;
  
  PRINTs(">>>Start  MPU_calibrate")
  pinMode(LED, OUTPUT);
    
  _accel_zero_x = _accel_zero_y = _accel_zero_z = 0.0;
  _gyro_zero_roll = _gyro_zero_pitch = _gyro_zero_yaw = 0.0;
  
  for (int i = 0; i < nb_mesures; i++) {
     if(i % 50 == 0) digitalWrite(LED, !digitalRead(LED));   // blink led
  
     _last_status = MPU6050_read_raw_roll_pitch_yaw();
     if (_last_status > 0) return _last_status;
     
     _accel_zero_x += _accel_raw_x;
     _accel_zero_y += _accel_raw_y;
     _accel_zero_z += _accel_raw_z;
     _gyro_zero_roll += _gyro_raw_roll;
     _gyro_zero_pitch += _gyro_raw_pitch;
     _gyro_zero_yaw += _gyro_raw_yaw;
     
     delay(5);  // 5 ms for Sample
  }  
  digitalWrite(LED, LOW);
  
  _accel_zero_x  /= nb_mesures;
  _accel_zero_y  /= nb_mesures;
  _accel_zero_z  /= nb_mesures; _accel_zero_z -= FE_ACCEL; //keep 1g
  _gyro_zero_roll /= nb_mesures;
  _gyro_zero_pitch /= nb_mesures;
  _gyro_zero_yaw /= nb_mesures;

   
  PRINT("_accel_zero_x: ",_accel_zero_x)  
  PRINT("_accel_zero_y: ",_accel_zero_y)   
  PRINT("_accel_zero_z: ",_accel_zero_z)   
  PRINT("_gyro_zero_roll: ",_gyro_zero_roll)
  PRINT("_gyro_zero_pitch: ",_gyro_zero_pitch)   
  PRINT("_gyro_zero_yaw: ",_gyro_zero_yaw)
  
  PRINTs(">>>End OK MPU_calibrate")
  return 0;        
}


uint8_t MPU6050Class::MPU6050_get_roll_pitch_yaw(double angle[3])
{
     double a_roll  = 0.0;
     double a_pitch = 0.0;
     double g_roll  = 0.0;
     double g_pitch = 0.0;
     double g_yaw   = 0.0;
     double a = 0.98;
     
         
     double ax = MPU6050_getAccel_x();
     if (_last_status > 0) return _last_status;

     double ay = MPU6050_getAccel_y();
     if (_last_status > 0) return _last_status;
         
     double az = MPU6050_getAccel_z();
     if (_last_status > 0) return _last_status;; 
             
     a_pitch  = atan2(ay, az) * 180.0/PI;  //The returned value of atan2 is in the range [-pi, +pi] radians => convert result in degree
     a_roll = atan2(-1.0*ax, sqrt(ay*ay + az*az)) * 180.0/PI; //The returned value of atan2 is in the range [-pi, +pi] radians  => convert result in degree

     double gyrox = MPU6050_getGyro_x();
     if (_last_status > 0) return _last_status;
         
     double gyroy = MPU6050_getGyro_y();
     if (_last_status > 0) return _last_status;
           
     double gyroz = MPU6050_getGyro_z();
     if (_last_status > 0) return _last_status;
     
     _currentTime = millis();  
     if (_previousTime > 0) {
        long dt = _currentTime - _previousTime;

        // integrate the gyros angular velocity in degree/sec 
        g_roll  = gyrox * (double)dt/1000.0;
        g_pitch = gyroy * (double)dt/1000.0;
        g_yaw   = gyroz * (double)dt/1000.0; 
           
        // adjust angles Roll & Pitch using complementary filter
        angle[0] = a * (_previous_roll  + g_roll)  + (1.0 - a) * a_roll;
        angle[1] = a * (_previous_pitch + g_pitch) + (1.0 - a) * a_pitch;    
        angle[2] = g_yaw;
     }
     else
     {
        angle[0] = a_roll;
        angle[1] = a_pitch;
        angle[2]  = 0.0;
     }  
      
     _previousTime = _currentTime;
     _previous_roll  =  angle[0];
     _previous_pitch =  angle[1]; 
     
     return 0;
}

uint8_t MPU6050Class::MPU6050_read_raw_roll_pitch_yaw()
{
     uint8_t msb = 0;
     uint8_t lsb = 0;  
     uint8_t nb_bytes_to_read = 14; // read 14 bytes
         
     Wire.beginTransmission(_address); 
     Wire.write(ACCEL_XOUT); // start address on the first register
     _last_status = Wire.endTransmission();
     if (_last_status > 0) return _last_status;
  
     _last_nb_receive = Wire.requestFrom(_address, nb_bytes_to_read); 
     if (_last_nb_receive != 14) {_last_status=WIRE_REQUEST_ERROR; return _last_status;} 
    
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _accel_raw_x  = (((int16_t)msb) << 8) | lsb;
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _accel_raw_y  = (((int16_t)msb) << 8) | lsb;
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _accel_raw_z  = (((int16_t)msb) << 8) | lsb;
       
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _temperature  = (((int16_t)msb) << 8) | lsb;
     
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _gyro_raw_roll  = (((int16_t)msb) << 8) | lsb;
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _gyro_raw_pitch  = (((int16_t)msb) << 8) | lsb;
     msb = Wire.read(); // value high byte
     lsb = Wire.read(); // value low byte
     _gyro_raw_yaw  = (((int16_t)msb) << 8) | lsb;     
     
     // change signes
     _accel_raw_x=-_accel_raw_x;
     _gyro_raw_pitch=-_gyro_raw_pitch;
     _gyro_raw_yaw=-_gyro_raw_yaw;
     
     return 0;
 }    

uint8_t MPU6050Class::MPU6050_compute_accel_gyro(double accel[3],double gyro[3])
{
     
      _last_status = MPU6050_read_raw_roll_pitch_yaw();
      if (_last_status > 0) return _last_status;
      
     // Apply zero values
     _accel_raw_x = _accel_raw_x - _accel_zero_x;
     _accel_raw_y = _accel_raw_y - _accel_zero_y;
     _accel_raw_z = _accel_raw_z - _accel_zero_z;
     _gyro_raw_roll  = _gyro_raw_roll  - _gyro_zero_roll;
     _gyro_raw_pitch = _gyro_raw_pitch - _gyro_zero_pitch;
     _gyro_raw_yaw   = _gyro_raw_yaw   - _gyro_zero_yaw;
     
     // filter
     _accel_filter_x = 0.8*_accel_filter_x + 0.2*_accel_raw_x;
     _accel_filter_y = 0.8*_accel_filter_y + 0.2*_accel_raw_y;
     _accel_filter_z = 0.8*_accel_filter_z + 0.2*_accel_raw_z;
     _gyro_filter_roll = 0.8*_gyro_filter_roll + 0.2*_gyro_raw_roll;
     _gyro_filter_pitch = 0.8*_gyro_filter_pitch + 0.2*_gyro_raw_pitch;
     _gyro_filter_yaw = 0.8*_gyro_filter_yaw + 0.2*_gyro_raw_yaw;

     // scale in °/s
     accel[0] = _accel_filter_x / FE_ACCEL;
     accel[1] = _accel_filter_y / FE_ACCEL;
     accel[2] = _accel_filter_z / FE_ACCEL;
    
     // scale in g
     gyro[0] = _gyro_filter_roll / FE_GYRO;
     gyro[1] = _gyro_filter_pitch / FE_GYRO;
     gyro[2] = _gyro_filter_yaw / FE_GYRO;

     return 0;
 }    
     
uint8_t MPU6050Class::MPU6050_compute_angle_gyro(uint32_t dt, double angle[2], double gyro[3])
{
     double angle_a_roll = 0.0;
     double angle_a_pitch = 0.0;
     double angle_g_roll = 0.0;
     double angle_g_pitch = 0.0;
     
     double w_accel[3];
     double w_gyro[3];

     _last_status = MPU6050_compute_accel_gyro(w_accel, w_gyro);
     if (_last_status > 0) return _last_status;
              
     // Compute angles accelerometer method
     angle_a_roll  = atan(w_accel[1] /(sqrt(w_accel[0]*w_accel[0] + w_accel[2]*w_accel[2]))) * (180.0/PI);
     angle_a_pitch = -atan(w_accel[0]/(sqrt(w_accel[1]*w_accel[1] + w_accel[2]*w_accel[2]))) * (180.0/PI); 
     
     _currentTime = millis();  
     if (_previousTime > 0  || dt > 0) {
        if (dt == 0) dt = _currentTime - _previousTime;
            
        // Compute angles gyro method   
        angle_g_roll += w_gyro[0]*((double)dt/1000000.0);
        angle_g_pitch += w_gyro[1]*((double)dt/1000000.0);

        // Transfer angle ROLL <--> PITCH in case of yaw rotation
        angle_g_roll  += angle_g_pitch * sin(w_gyro[2]*((double)dt/1000000.0)*0.0174533); // (pi/180=0,0174533)
        angle_g_pitch -= angle_g_roll  * sin(w_gyro[2]*((double)dt/1000000.0)*0.0174533);
     }
     else
     {
        angle_g_roll  = angle_a_roll;  // initialize gyro with accel the first time.
        angle_g_pitch = angle_a_pitch;
     }
  
     // Apply complementary filter 
     angle[0]  = 0.9996*angle_g_roll  + 0.0004*angle_a_roll;
     angle[1]  = 0.9996*angle_g_pitch + 0.0004*angle_a_pitch;
     
     gyro[0] = w_gyro[0];
     gyro[1] = w_gyro[1];
     gyro[2] = w_gyro[2];
     
     _previousTime = _currentTime;
      
     return 0;
}

uint8_t MPU6050Class::MPU6050_getStatus()
{
  return _last_status;
}

uint8_t MPU6050Class::MPU6050_getAddress()
{
  return _address;
}


double MPU6050Class::MPU6050_getTemperature()

{
  if (_temperature != 0) return (((double)_temperature / 340.0)+ 36.53); 
  else return -1;  
}

void MPU6050Class::MPU6050_getZero(double accel[3],double gyro[3])
{
    accel[0] = _accel_zero_x;
    accel[1] = _accel_zero_y;   
    accel[2] = _accel_zero_z;
    gyro[0] =  _gyro_zero_roll;
    gyro[1] =  _gyro_zero_pitch;  
    gyro[2] =  _gyro_zero_yaw;    
}