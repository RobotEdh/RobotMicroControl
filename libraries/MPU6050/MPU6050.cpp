#include <Arduino.h>
#include <MPU6050.h>


#define ADDRESS_DEFAULT 0X68  


MPU6050Class::MPU6050Class(void)
{
}


uint8_t MPU6050Class::MPU6050_CheckDeviceID()
{
    uint8_t deviceID = MPU6050_readReg(WHO_AM_I);
    if (_last_status > 0) return _last_status;
    
    if (deviceID == MPU6050_ID) return 0;
    else return deviceID;
}

uint8_t MPU6050Class::MPU6050_init()
{
    Serial.println(">>>Start  MPU_init"); 
    
    // Setup I2C
    _address =ADDRESS_DEFAULT;  
    Serial.print("_address: ");Serial.println(_address,HEX); 

    
    // Reset
    MPU6050_writeReg(PWR_MGMT_1, B10000000); //PWR_MGMT_1    -- DEVICE_RESET
    if (_last_status > 0) return _last_status;
    delay(50); // small delay of ~50ms may be desirable after triggering a reset
   
   // Wake up device and select GyroZ clock (better performance)
    MPU6050_writeReg(PWR_MGMT_1, B00000011); //PWR_MGMT_1    -- SLEEP 0; CYCLE 0; TEMP_DIS 0; CLKSEL 011 (clock source is set to PLL with Z Gyro reference)
    if (_last_status > 0) return _last_status;
        
     /** Set the The DLPF_CFG parameter = the digital low pass filter configuration.    
     * It also determines the internal sampling rate used by the device as shown in
     * the table below.
     *          |   ACCELEROMETER    |           GYROSCOPE
     * DLPF_CFG | Bandwidth | Delay  | Bandwidth | Delay  | Sample Rate
     * ---------+-----------+--------+-----------+--------+-------------
     * 0        | 260Hz     | 0ms    | 256Hz     | 0.98ms | 8kHz
     * 1        | 184Hz     | 2.0ms  | 188Hz     | 1.9ms  | 1kHz
     * 2        | 94Hz      | 3.0ms  | 98Hz      | 2.8ms  | 1kHz
     * 3        | 44Hz      | 4.9ms  | 42Hz      | 4.8ms  | 1kHz
     * 4        | 21Hz      | 8.5ms  | 20Hz      | 8.3ms  | 1kHz
     * 5        | 10Hz      | 13.8ms | 10Hz      | 13.4ms | 1kHz
     * 6        | 5Hz       | 19.0ms | 5Hz       | 18.6ms | 1kHz
     * => Choose DLPF_CFG = 4 => ACC bandwidth = 21Hz  GYRO bandwidth = 20Hz: compromise between filtering noise and delay
     */
    MPU6050_writeReg(CONFIG, B00000100); //CONFIG        -- EXT_SYNC_SET 000 (disable input pin for data sync) ; DLPF_CFG = 4 (100) => ACC bandwidth = 21Hz  GYRO bandwidth = 20Hz
    if (_last_status > 0) return _last_status;
        
    /** The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
     *
     * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
     *
     * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
     * 7), and 1kHz when the DLPF is enabled (see Register 26).
     *
     * Note: The accelerometer output rate is 1kHz. This means that for a Sample
     * Rate greater than 1kHz, the same accelerometer sample may be output to the
     * FIFO, DMP, and sensor registers more than 
     * => Choose Divider = 4 => Sample rate = 1Khz/(4+1) = 200Hz ie 5ms
     */        
    MPU6050_writeReg(SMPRT_DIV, 4); //SMPRT_DIV        -- Divider = 4
    if (_last_status > 0) return _last_status;
        
        
    MPU6050_writeReg(GYRO_CONFIG, B00000000); //GYRO_CONFIG   -- no Self test -- FS_SEL = 000: (Full Scale Range set to +/- 250 deg/sec)
    if (_last_status > 0) return _last_status;
        
    MPU6050_writeReg(ACCEL_CONFIG, B00000000);  //ACCEL_CONFIG  -- no Self test -- AFS_SEL = 00 (Full Scale Range set to +/-2g) 
    if (_last_status > 0) return _last_status;
        
    _ax_zero = 0.0;  
    _ay_zero = 0.0; 
    _az_zero = 0.0; 
    _gyrox_zero = 0.0;      
    _gyroy_zero = 0.0;
    _gyroz_zero = 0.0;
    
    _previousTime = 0;
    _a = 0.98;
  
    Serial.println("<<<End OK MPU_init");

    return 0;
}

// Write an 8-bit register
void MPU6050Class::MPU6050_writeReg(uint8_t reg, uint8_t value)
{
  Wire.beginTransmission(_address);
  Wire.write(reg);
  Wire.write(value);
  _last_status = Wire.endTransmission();
}

// Read an 8-bit register
uint8_t MPU6050Class::MPU6050_readReg(uint8_t reg)
{
  uint8_t value=0;

  Wire.beginTransmission(_address);
  Wire.write(reg);
  _last_status = Wire.endTransmission();
  if (_last_status > 0) return _last_status;

  Wire.requestFrom(_address, (uint8_t)1);
  value = Wire.read();

  return value;
}

// Read a 16-bit register
int16_t MPU6050Class::MPU6050_readReg16Bit(uint8_t reg)
{
  int16_t value;

  Wire.beginTransmission(_address);
  Wire.write(reg);
  _last_status = Wire.endTransmission();
  if (_last_status > 0) return _last_status;
  
  Wire.requestFrom(_address, (uint8_t)2);
  uint8_t msb = Wire.read(); // value high byte
  uint8_t lsb = Wire.read(); // value low byte
  value  = (int16_t)(msb << 8 | lsb);

  return value;
}


double MPU6050Class::MPU6050_getTemperature()
{
  int16_t temperature = MPU6050_readReg16Bit(TEMP_OUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)temperature / 340.0)+ 36.53); // refer to formula section 4.18
}

double MPU6050Class::MPU6050_getAccel_x()
{
  int16_t accel_x = MPU6050_readReg16Bit(ACCEL_XOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_x / 16384.0) - _ax_zero);  // Full Scale Range ?2g => 16384 LSB/g
}
double MPU6050Class::MPU6050_getAccel_y()
{
  int16_t accel_y = MPU6050_readReg16Bit(ACCEL_YOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_y / 16384.0) - _ay_zero); // Full Scale Range ?2g => 16384 LSB/g
}
double MPU6050Class::MPU6050_getAccel_z()
{
  int16_t accel_z = MPU6050_readReg16Bit(ACCEL_ZOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)accel_z / 16384.0) - _az_zero); // Full Scale Range ?2g => 16384 LSB/g
}

double MPU6050Class::MPU6050_getGyro_x()
{
  int16_t gyro_x = MPU6050_readReg16Bit(GYRO_XOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_x / 131.0) - _gyrox_zero);  // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}
double MPU6050Class::MPU6050_getGyro_y()
{
  int16_t gyro_y = MPU6050_readReg16Bit(GYRO_YOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_y / 131.0) - _gyroy_zero); // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}
double MPU6050Class::MPU6050_getGyro_z()
{
  int16_t gyro_z = MPU6050_readReg16Bit(GYRO_ZOUT);
  if (_last_status > 0) return (double)_last_status;
  else return (((double)gyro_z / 131.0) - _gyroz_zero); // Full Scale Range ? 250 ?/s => 131 LSB/?/s
}

uint8_t MPU6050Class::MPU6050_calibrate()
{
  double ax_tot = 0.0;
  double ay_tot = 0.0;
  double az_tot = 0.0;
  double gyrox_tot = 0.0;
  double gyroy_tot = 0.0;
  double gyroz_tot = 0.0;
  
  double d = 0.0;
  
  Serial.println(">>>Start  MPU_calibrate"); 
    
  _ax_zero = 0.0;
  _ay_zero = 0.0;
  _az_zero = 0.0;
  _gyrox_zero = 0.0;
  _gyroy_zero = 0.0;
  _gyroz_zero = 0.0;
  
  for (int i = 0; i < 255; i++) {
     d = MPU6050_getAccel_x();
     if (_last_status > 0) return _last_status; 
     else ax_tot += d;
        
     d = MPU6050_getAccel_y();
     if (_last_status > 0) return _last_status;
     else ay_tot += d;
        
     d = MPU6050_getAccel_z();
     if (_last_status > 0) return _last_status;
     else az_tot += d;   
        
     d = MPU6050_getGyro_x();
     if (_last_status > 0) return _last_status;
     else gyrox_tot += d;
        
     d = MPU6050_getGyro_y();
     if (_last_status > 0) return _last_status;   
     else gyroy_tot += d; 
            
     d = MPU6050_getGyro_z();
     if (_last_status > 0) return _last_status;
     else gyroz_tot += d;     
     
     delay(5);  // 5 ms for Sample
  }
  _ax_zero = ax_tot/255.0;
  _ay_zero = ay_tot/255.0;
  _az_zero = (az_tot/255.0) - 1.0;  // keep 1g
  _gyrox_zero = gyrox_tot/255.0;
  _gyroy_zero = gyroy_tot/255.0;
  _gyroz_zero = gyroz_tot/255.0;
  
  Serial.print("_ax_zero: ");Serial.println(_ax_zero);  
  Serial.print("_ay_zero: ");Serial.println(_ay_zero);   
  Serial.print("_az_zero: ");Serial.println(_az_zero);   
  Serial.print("_gyrox_zero: ");Serial.println(_gyrox_zero);
  Serial.print("_gyroy_zero: ");Serial.println(_gyroy_zero);   
  Serial.print("_gyroz_zero: ");Serial.println(_gyroz_zero);
  
  Serial.println(">>>End OK MPU_calibrate");
  return 0;        
}


uint8_t MPU6050Class::MPU6050_get_roll_pitch_yaw(double angle[3])
{
     double a_roll  = 0.0;
     double a_pitch = 0.0;
     double g_roll  = 0.0;
     double g_pitch = 0.0;
     double g_yaw   = 0.0;
     
         
     double ax = MPU6050_getAccel_x();
     if (_last_status > 0) return _last_status;

     double ay = MPU6050_getAccel_y();
     if (_last_status > 0) return _last_status;
         
     double az = MPU6050_getAccel_z();
     if (_last_status > 0) return _last_status;; 
             
     a_roll  = atan2(ay, az) * 180.0/PI;  //The returned value of atan2 is in the range [-pi, +pi] radians => convert result in degree
     a_pitch = atan2(-1.0*ax, sqrt(ay*ay + az*az)) * 180.0/PI; //The returned value of atan2 is in the range [-pi, +pi] radians  => convert result in degree

     double gyrox = MPU6050_getGyro_x();
     if (_last_status > 0) return _last_status;
         
     double gyroy = MPU6050_getGyro_y();
     if (_last_status > 0) return _last_status;
           
     double gyroz = MPU6050_getGyro_z();
     if (_last_status > 0) return _last_status;
     
     _currentTime = millis();  
     if (_previousTime > 0) {
        long dt = _currentTime - _previousTime;

        // integrate the gyros angular velocity in degree/sec 
        g_roll  = gyrox * (double)dt/1000.0;
        g_pitch = gyroy * (double)dt/1000.0;
        g_yaw   = gyroz * (double)dt/1000.0; 
           
        // adjust angles Roll & Pitch using complementary filter
        angle[0] = _a * (_previous_roll  + g_roll)  + (1.0 - _a) * a_roll;
        angle[1] = _a * (_previous_pitch + g_pitch) + (1.0 - _a) * a_pitch;    
        angle[2] = g_yaw;
     }
     else
     {
        angle[0] = a_roll;
        angle[1] = a_pitch;
        angle[2]  = 0.0;
     }  
      
     _previousTime = _currentTime;
     _previous_roll  =  angle[0];
     _previous_pitch =  angle[1]; 
     
     return 0;
}

uint8_t MPU6050Class::MPU6050_getStatus()
{
  return _last_status;
}

uint8_t MPU6050Class::MPU6050_getAddress()
{
  return _address;
}